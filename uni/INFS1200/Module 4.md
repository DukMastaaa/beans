# Module 4: Database Design Theory

## Update Anomalies

1. Modification anomaly: updating value for one attribute in a tuple makes other attributes in other tuples inconsistent
2. Deletion anomaly: by deleting a tuple, we no longer store information for an attribute.
3. Insertion anomaly: cannot insert information without creating a whole tuple

## Decomposition of Relation

A decomposition of R replaces R with two or more relations such that:

* new relations' attributes is proper subset of R's attributes (no attributes included which are not in R)
* every attribute of R appears in at least 1 new relation

A decomposition is lossless if after the decomposition, all tuples **(and no more)** from the original relation can be retrieved using a join.

## Design Guidelines

1. Design relations where the meaning is clear
   1. use good attribute naming
   2. don't clump multiple attributes that don't belong together
2. Make sure no update anomalies can occur
3. Don't put attributes in a base relation where they could be `null`
   1. if unavoidable, make sure they only occur in exceptional cases
4. Ensure that relations can be joined on primary/foreign keys such that no spurious (wrong) tuples are generated

## Functional Dependencies

If one attribute is functionally dependent on another (e.g. A is functionally dependent on B), then A uniquely determines B. So, if we know value of A, we know value of B.

Formally, X -> Y holds on a relation R if for every legal instance of R (named r), for all tuples t1 and t2 in r, 
t1[X] = t2[X] => t1[Y] = t2[Y].

### Finding FDs

We can check if some FD is violated in a relation instance, but we cannot tell if it holds over the whole relation. FDs must be determined using knowledge of the system or UoD.

Quick tip: if a column has no repeated values, you cannot tell whether a FD involving that column (on LHS of arrow) is violated.

### Implicit FDs

Given a set of explicit FDs F, we can determine implicit ones. For example, if ID -> level, level -> salary, then ID -> salary is an implicit FD.

Notation: F $\vDash$ X $\rightarrow$ Y, so X determines Y under F.

### Closure of F

Given a set of FDs F, many implicit FDs can be derived.

Trivial FDs are FDs stating that something implies itself, e.g. A -> A and ABC -> AB.
Non-trivial FDs are like A -> B, A -> AB.

The closure of F (denoted as F^{+}, F superscript +) is the set of all FDs that can be implied by F. This includes trivial and non-trivial FDs.

## Keys

A key is a minimal set of attributes that functionally determines all attributes in the relation. 
A superkey uniquely identifies the relation but does not need to be minimal.
All keys are superkeys, but not all superkeys are keys.

## Inference Rules

Helps us infer FDs from a set of valid FDs. First three rules are called Armstrong's Axioms. Refer to them as IR1, IR2 etc.

Let X, Y, Z be sets of attributes.

1. Reflexivity:  If Y $\subseteq$ X, then X -> Y.
   e.g. {ID, level} -> level
2. Augmentation: If X -> Y, then XZ -> YZ forall Z.
   e.g. if ID -> level then {ID, salary} -> {level, salary}.
3. Transitivity: If X -> Y and Y -> Z, then X -> Z.
   e.g. if ID -> level and level -> salary then ID -> salary.

Armstrong's Axioms are:

* sound - any FD inferred using the axioms holds in every legal relation instance
* complete - all possible inferred FDs can be generated by repeatedly applying these rules

Other three rules are for convenience and can be derived from Armstrong's Axioms.

4. Decomposition: If X -> YZ, then X -> Y (and X -> Z)
   e.g. if ID -> {level, salary} then ID -> level

   Proof:
   $$
   X \rightarrow YZ \vDash X \rightarrow Y: \\
   \begin{align*}
	X &\rightarrow YZ  &&\text{(given)} \\
      	YZ &\rightarrow Y  &&\text{(IR1 as } Y \subset YZ\text{)} \\
      	X &\rightarrow Y  &&\text{(IR3)}
   \end{align*}
   $$
   
5. Union: If X -> Y and X -> Z, then X -> YZ
   e.g. if ID -> level and ID -> salary then ID -> {level, salary}

   Proof:
   $$
   \{X \rightarrow Y, X\rightarrow Z\} \vDash X \rightarrow YZ: \\
   \begin{align*}
   	X &\rightarrow Y &&\text{(given)} \\
   	X &\rightarrow Z &&\text{(given)} \\
   	XX &\rightarrow XY &&\text{(IR2)} \\
   	X &\rightarrow XY &&(X=XX) \\
   	XY &\rightarrow YZ &&\text{(IR2)} \\
   	X &\rightarrow YZ &&\text{(IR3)}
   \end{align*}
   $$
   
6. Pseudotransitivity: If X -> Y and WY -> Z, then WX -> Z
   e.g. if level -> salary and {grants, salary} -> citation then {grants, level} -> citation

   Proof:
   $$
   \{X\rightarrow Y, WY \rightarrow Z\} \vDash WX \rightarrow Z: \\
   \begin{align*}
   	X &\rightarrow Y &&\text{(given)} \\
   	WY &\rightarrow Z &&\text{(given)} \\
   	WX &\rightarrow WY &&\text{(IR2)} \\
   	WX &\rightarrow Z &&\text{(IR3)}
   \end{align*}
   $$

## F+ and X+

F+ is all FDs which can be inferred from F. We can use inference rules to compute F+, but it is very time-consuming and not necessary (for the purpose of removing anomalies). Can instead compute closure of an attribute, which is the set of attributes that it determines (written X+). 

### Computing X+ informally

1. X+ initially contains all attributes in X.
2. For each FD in F, if LHS of FD is a subset of X+, then add RHS to X+.
3. If step 2 resulted in changes in X+, then goto 2, else finish.

e.g. `Employee[_ID, level, salary]`, `F = {ID -> level, level -> salary, ID -> name}`

1. ID+ = {ID}
2. ID+ = {ID, level} (using ID -> level)
3. ID+ = {ID, level, salary} (using level -> salary)
4. ID+ = {ID, level, salary, name} (using salary -> name).

### Finding Superkeys

To show that a set of attributes is a superkey for a relation, compute its closure. If X+ is equal to the set of attributes of the relation, X is a superkey.

### Finding Keys

Given a complete set of FDs F on relation R, 
for any subset S of R's attributes,
S is a key iff:

1. S+ = R
2. There is no S' $\subset$ S such that S'+ = R.

If R has n attributes, there are $2^n$ attributes to consider.

#### Tips for finding keys

* If an attribute does not appear in the RHS of any FDs in F, a key must contain that attribute.

* If a subset S is a key, there is no need to test any superset of S

* One relation can have multiple keys of different lengths

  * e.g. if ABC is a key, ABCD is not a key but ABDE could be.


## Normalisation

### Prime

Prime attribute: attribute in any candidate key (not necessarily primary key)
Non-prime attribute: attribute not in any candidate key

### 1NF

Domains of attrs include only atomic (simple, indivisible) values, so no sets of values, nested attrs or both.

**Test: ** R should not contain multivalued attrs or nested relations.

### Full, Partial FDs

X -> Y is *full* if a removal of any attribute A from X causes the FD to not hold. It is *partial* if some attribute can be removed from X and the FD still holds.

### 2NF

Every non-prime attribute A in R is fully functionally dependent on the primary key of R.

Formally, R with F is in 2NF iff
forall non-trivial FDs X -> A in F,

1. X is **not** a proper subset of a candidate key for R, **or**
2. A is a prime attribute.

**Test:** LHS of any non-trivial FD in F+ is not a proper subset of a candidate key, or RHS is prime attribute.

Hints:

- if key is 1 attribute only, it will fulfil this condition (if it passes 1NF) because you cannot get a proper subset of the key without it being empty
- it's essentially saying no part of the key can be the LHS of a dependency involving non-prime attr on the RHS

this eliminates anomalies due to partial dependencies, but not *transitive* dependencies.

### Transitive FDs

X -> Y in R is *transitive* if there exists some set of attrs Z in R such that

- Z is neither a candidate key or subset of key of R
- X -> Z and Z -> Y.

### 3NF

similar to 2NF conditions. Formally,

Formally, R with F is in 3NF iff
forall non-trivial FDs X -> A in F,

1. X is a superkey of R **or**
2. A is a prime attribute.

**Test:** for all non-trivial X -> A where A is non-prime, X is superkey.

Most 3NF tables are free of anomalies but some (rarely met in practice) do contain them.

### BCNF

removes all anomalies, but does not preserve all FDs.

formally, R with F is in BCNF iff
forall non-trivial FDs X -> A in F,
X is a superkey of R.

**Test:** all LHS of non-trivial FDs should be superkeys.

### Preserving Dependencies

Dependencies are preserved if after decomposing a relation, the closure of the FDs in all composed relations combined is equal to the closure of the FDs in the original relation.

Decomposing a relation into BCNF may not be dependency-preserving.

This means that when joining the decomposed relations back up into one table, some FDs may be violated (although everything is fine on a local level within each decomposed table).

Also, note that BCNF \subset 3NF \subset 2NF \subset 1NF.

## Normalisation to BCNF by Decomposition

steps:

1. actually check if the relation is not in BCNF. if it is already in BCNF, no decomposition required
2. find keys of relation
3. go through F one FD at a time.
   1. for the FD X -> Y, is X a superkey?
      1. if yes, leave this 'branch' of the relation
      2. if no, decompose the relation as follows:
         1. the first decomposed relation contains all attributes except those in Y.
         2. the second decomposed relation contains attributes of X and Y only.
   2. repeat the process for each decomposed relation, until no decomposition left
4. process finished, resulting relations are decomposed.

### Determining if FDs hold after decomposition

let's say you have some R and some FD X -> Y. To determine whether X -> Y holds in R,

1. is X \cup Y \subseteq R? if yes continue
2. find X+ (not sure why we do this)

## Normalisation to 3NF by Synthesis

### Minimal Cover

we rely on minimal cover.

steps to compute minimal cover:

1. split up RHS of each FD in F, call this set of FDs F1
2. for each X -> Y in F1 such that X contains more than 1 attribute, see whether X+ = (X-B)+ for some B in X. If so, replace X with X-B. In other words, see if you can remove any attribute from X such that the closure is the same. If you can, replace X with (X - removed attribute). Call the new set of FDs F2.
3. Check for redundancy in resulting FDs.
   For each X -> Y in F2, see if you can infer X -> Y using all other FDs in F2 except X -> Y. If you can, X -> Y is redundant and can be removed. Call the new set of FDs F3.

F3 is the minimal cover of F. You can union FDs with the same LHS to simplify notation.

### 3NF Synthesis

steps to normalise to 3NF:

1. compute minimal cover with union.
2. compute candidate keys of R.
3. for each FD X -> Y in minimal cover, create a new relation with attributes X \union Y.
4. if there is a candidate key whose attributes are not in any new relation, create a new relation whose attributes are the candidate key.
5. check for redundancy - this includes duplicated relations, or a relation which is a projection of another relation.

the resulting relations should each have either no non-trivial FDs (this is if its attributes are a candidate key) or one FD from the minimal cover. end